import type { AISummaryOptions, CommitSuggestion, AIProvider } from '../types/ai.js';
import type { AIConfig } from '../types/config.js';

export type { AISummaryOptions, CommitSuggestion, AIProvider };

export class MockAIProvider implements AIProvider {
  isConfigured(): boolean {
    return false;
  }

  async generateCommitMessage(_diff: string, _options?: AISummaryOptions): Promise<CommitSuggestion> {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      type: 'feat',
      subject: 'AI-generated commit message (mock)',
      body: 'This is a placeholder AI-generated commit message. To enable real AI summaries, configure an AI provider in your config.',
      confidence: 0.8,
      reasoning: 'Mock AI provider - not a real analysis'
    };
  }
}

export class OpenAIProvider implements AIProvider {
  private apiKey: string | undefined;
  private _model: string;

  constructor(apiKey?: string, model = 'gpt-3.5-turbo') {
    this.apiKey = apiKey;
    this._model = model;
  }

  get model(): string {
    return this._model;
  }

  isConfigured(): boolean {
    return !!this.apiKey;
  }

  async generateCommitMessage(diff: string, options?: AISummaryOptions): Promise<CommitSuggestion> {
    if (!this.isConfigured()) {
      throw new Error('OpenAI API key not configured');
    }

    const model = options?.model || this._model;
    const temperature = options?.temperature ?? 0.7;
    const maxTokens = options?.maxTokens ?? 150;

    const prompt = `Analyze this git diff and generate a conventional commit message.

Rules:
- Subject line should be ≤ 50 characters
- Use conventional commit format: type(scope): subject
- Choose appropriate type: feat, fix, docs, style, refactor, test, chore, etc.
- Be concise and descriptive
- Optional body for more details

Git diff:
${diff}

Respond with JSON in this format:
{
  "type": "feat",
  "scope": "auth",
  "subject": "add user authentication",
  "body": "Implement JWT-based authentication system with login/logout functionality",
  "confidence": 0.9,
  "reasoning": "Added new authentication functionality"
}`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model,
          messages: [
            { role: 'system', content: 'You are a helpful assistant that generates conventional git commit messages.' },
            { role: 'user', content: prompt }
          ],
          temperature,
          max_tokens: maxTokens,
          response_format: { type: 'json_object' }
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      const content = data.choices?.[0]?.message?.content;
      
      if (!content) {
        throw new Error('No response from OpenAI API');
      }

      const parsed = JSON.parse(content);
      
      return {
        type: parsed.type || 'feat',
        scope: parsed.scope,
        subject: parsed.subject || 'update code',
        body: parsed.body,
        confidence: parsed.confidence || 0.7,
        reasoning: parsed.reasoning || 'Generated by OpenAI'
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`OpenAI API error: ${error.message}`);
      }
      throw error;
    }
  }
}

export class AnthropicProvider implements AIProvider {
  private apiKey: string | undefined;
  private _model: string;

  constructor(apiKey?: string, model = 'claude-3-haiku-20240307') {
    this.apiKey = apiKey;
    this._model = model;
  }

  get model(): string {
    return this._model;
  }

  isConfigured(): boolean {
    return !!this.apiKey;
  }

  async generateCommitMessage(diff: string, options?: AISummaryOptions): Promise<CommitSuggestion> {
    if (!this.isConfigured()) {
      throw new Error('Anthropic API key not configured');
    }

    const model = options?.model || this._model;
    const temperature = options?.temperature ?? 0.7;
    const maxTokens = options?.maxTokens ?? 150;

    const prompt = `Analyze this git diff and generate a conventional commit message.

Rules:
- Subject line should be ≤ 50 characters
- Use conventional commit format: type(scope): subject
- Choose appropriate type: feat, fix, docs, style, refactor, test, chore, etc.
- Be concise and descriptive
- Optional body for more details

Git diff:
${diff}

Respond with JSON in this format:
{
  "type": "feat",
  "scope": "auth",
  "subject": "add user authentication",
  "body": "Implement JWT-based authentication system with login/logout functionality",
  "confidence": 0.9,
  "reasoning": "Added new authentication functionality"
}`;

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey!,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model,
          max_tokens: maxTokens,
          temperature,
          messages: [
            {
              role: 'user',
              content: prompt
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`Anthropic API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as any;
      const content = data.content?.[0]?.text;
      
      if (!content) {
        throw new Error('No response from Anthropic API');
      }

      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No valid JSON found in Anthropic response');
      }

      const parsed = JSON.parse(jsonMatch[0]);
      
      return {
        type: parsed.type || 'feat',
        scope: parsed.scope,
        subject: parsed.subject || 'update code',
        body: parsed.body,
        confidence: parsed.confidence || 0.7,
        reasoning: parsed.reasoning || 'Generated by Claude'
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Anthropic API error: ${error.message}`);
      }
      throw error;
    }
  }
}

export function createAIProvider(options?: AISummaryOptions): AIProvider {
  const provider = options?.provider || 'mock';
  
  switch (provider) {
    case 'openai':
      return new OpenAIProvider(options?.apiKey, options?.model);
    case 'anthropic':
      return new AnthropicProvider(options?.apiKey, options?.model);
    default:
      return new MockAIProvider();
  }
}

export async function generateCommitSuggestion(
  diff: string, 
  options?: AISummaryOptions
): Promise<CommitSuggestion> {
  const provider = createAIProvider(options);
  
  if (!provider.isConfigured() && options?.provider && options.provider !== 'mock') {
    console.warn(`AI provider ${options.provider} not configured, falling back to mock`);
    return createAIProvider({ ...options, provider: 'mock' }).generateCommitMessage(diff, options);
  }
  
  return provider.generateCommitMessage(diff, options);
}

export function isAIConfigured(options?: AISummaryOptions): boolean {
  const provider = createAIProvider(options);
  return provider.isConfigured();
}

/**
 * Generate AI-powered commit summary from git diff
 * @param diff - Git diff string
 * @param config - AI configuration
 * @returns Promise resolving to subject and body
 */
export async function generateAISummary(
  diff: string, 
  config: AIConfig
): Promise<{ subject: string; body: string }> {
  // Convert AIConfig to AISummaryOptions
  const options: AISummaryOptions = {
    provider: config.provider || 'mock'
  };

  // Only set optional properties if they exist
  if (config.apiKey) options.apiKey = config.apiKey;
  if (config.model) options.model = config.model;
  if (config.temperature !== undefined) options.temperature = config.temperature;
  if (config.maxTokens !== undefined) options.maxTokens = config.maxTokens;

  // If no API key provided for a real provider, fall back to mock
  if (!config.apiKey && config.provider && config.provider !== 'mock') {
    options.provider = 'mock';
  }

  try {
    const suggestion = await generateCommitSuggestion(diff, options);
    
    // Format the subject line with conventional commit format
    let subject = suggestion.subject;
    if (suggestion.type) {
      const scope = suggestion.scope ? `(${suggestion.scope})` : '';
      subject = `${suggestion.type}${scope}: ${suggestion.subject}`;
    }

    // Ensure subject line is within limit (≤ 50 chars ideally)
    if (subject.length > 50) {
      subject = subject.substring(0, 47) + '...';
    }

    return {
      subject,
      body: suggestion.body || ''
    };
  } catch (error) {
    // Fallback to mock if AI provider fails
    console.warn('AI provider failed, falling back to mock:', error);
    
    const mockProvider = new MockAIProvider();
    const suggestion = await mockProvider.generateCommitMessage(diff);
    
    return {
      subject: suggestion.subject,
      body: suggestion.body || ''
    };
  }
}