import type { AIProvider, AISummaryOptions, CommitSuggestion } from '../../types/ai.js';
import { lazy } from '../lazyImport.js';

export class AnthropicProvider implements AIProvider {
  private apiKey: string | undefined;
  private _model: string;

  constructor(apiKey?: string, model = 'claude-3-haiku-20240307') {
    this.apiKey = apiKey;
    this._model = model;
  }

  get model(): string {
    return this._model;
  }

  isConfigured(): boolean {
    return !!this.apiKey;
  }

  async generateCommitMessage(diff: string, options?: AISummaryOptions): Promise<CommitSuggestion> {
    if (!this.isConfigured()) {
      throw new Error('Anthropic API key not configured');
    }

    const model = options?.model || this._model;
    const temperature = options?.temperature ?? 0.7;
    const maxTokens = options?.maxTokens ?? 150;

    const prompt = `Analyze this git diff and generate a conventional commit message.

Rules:
- Subject line should be â‰¤ 50 characters
- Use conventional commit format: type(scope): subject
- Choose appropriate type: feat, fix, docs, style, refactor, test, chore, etc.
- Be concise and descriptive
- Optional body for more details

Git diff:
${diff}

Respond with JSON in this format:
{
  "type": "feat",
  "scope": "auth",
  "subject": "add user authentication",
  "body": "Implement JWT-based authentication system with login/logout functionality",
  "confidence": 0.9,
  "reasoning": "Added new authentication functionality"
}`;

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey!,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model,
          max_tokens: maxTokens,
          temperature,
          messages: [
            {
              role: 'user',
              content: prompt
            }
          ]
        })
      });

      // Handle specific HTTP status codes with lazy-loaded error classes
      if (response.status === 429) {
        const { ClaudeRateLimitError } = await lazy(() => import('../../types/ai.js'));
        throw new ClaudeRateLimitError('Rate limited');
      }

      if (response.status === 400) {
        const errorData = (await response.json().catch(() => ({}))) as any;
        const errorMessage = errorData.error?.message || errorData.error || 'Bad request';
        const { ClaudeValidationError } = await lazy(() => import('../../types/ai.js'));
        throw new ClaudeValidationError(errorMessage);
      }

      if (!response.ok) {
        throw new Error(`Anthropic API error: ${response.status} ${response.statusText}`);
      }

      const data = (await response.json()) as any;
      const content = data.content?.[0]?.text;

      if (!content) {
        throw new Error('No response from Anthropic API');
      }

      // Try to extract JSON from the response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No valid JSON found in Anthropic response');
      }

      const parsed = JSON.parse(jsonMatch[0]);

      // Return enhanced response with usage information
      return {
        type: parsed.type || 'feat',
        scope: parsed.scope,
        subject: parsed.subject || 'update code',
        body: parsed.body,
        confidence: parsed.confidence || 0.7,
        reasoning: parsed.reasoning || 'Generated by Claude'
      };
    } catch (error) {
      // Re-throw specific error types
      const { ClaudeRateLimitError, ClaudeValidationError } = await lazy(() => import('../../types/ai.js'));
      if (error instanceof ClaudeRateLimitError || error instanceof ClaudeValidationError) {
        throw error;
      }

      if (error instanceof Error) {
        throw new Error(`Anthropic API error: ${error.message}`);
      }
      throw error;
    }
  }
}
